.define public GPIO_ADDR 0	// 18 address bits starting at GPIO 0
.define public GPIO_DIR 19	// set direction of data pin buffer
.define public GPIO_OE 20	// Output Enable - pin 22 of 27c512, /CSn on MSX slot
.define public GPIO_CE 21	// Chip Enable - pin 20 of 27c512, /SLTSL on MSX slot
.define public GPIO_DATA 22	// 8 data bits
.define public PIN_COUNT 32

.define        IRQ_SEL 0

.program wait_sel
idle:
	wait 0 gpio GPIO_CE [31]	; wait for /CE to go low, allow cycle to settle

	mov y, pins		; read in all pins
	;; mov osr, y		; copy to osr to do logical shift
	;; out null, GPIO_CE	; dump lower bits
	;; out x, 2		; grab the two /OE /CE bits we want
	;; jmp x-- idle		; if X is not zero then /OE or /CE are high

	in y, PIN_COUNT		; autopush address and data bits to RX FIFO
	irq IRQ_SEL		; signal we are active

.wrap_target
	mov x, pins		; read all pins again
	jmp x!=y idle		; if any have changed, restart and check /OE and /CE again
.wrap
